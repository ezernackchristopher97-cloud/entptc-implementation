"""
Clifford Algebra Cl(3,0) Implementation

Reference: ENTPC.tex Definition 2.3 (lines 242-252)

From ENTPC.tex:

Definition 2.3 (Clifford Algebra for Semantic Encoding): The Clifford algebra
Cl(3,0) is generated by basis vectors {e₁, e₂, e₃} satisfying the relation
eᵢeⱼ + eⱼeᵢ = 2δᵢⱼ. The algebra has a graded structure of dimension 2³ = 8,
consisting of:
- Grade 0: Scalars (1 element)
- Grade 1: Vectors (3 elements: e₁, e₂, e₃)
- Grade 2: Bivectors (3 elements: e₁e₂, e₂e₃, e₃e₁)
- Grade 3: Pseudoscalar (1 element: e₁e₂e₃)

In EntPTC:
- Clifford algebra serves as global integration layer
- Bivectors encode semantic and relational information geometrically
- Quaternions are isomorphic to even subalgebra of Cl(3,0)
- Mapping Π: H_H → Cl(3,0) via rotor Π(q) = e^(-B/2)

Two-stage process:
1. Local quaternionic filtering (context-dependent stabilization)
2. Embedding into global Clifford algebra (semantic integration)
"""

import numpy as np
from typing import Union, Tuple
from dataclasses import dataclass

@dataclass
class CliffordElement:
 """
 Element of Clifford algebra Cl(3,0).
 
 Per ENTPC.tex: 8-dimensional algebra with graded structure.
 
 Representation: c = c₀ + c₁e₁ + c₂e₂ + c₃e₃ + c₁₂e₁e₂ + c₂₃e₂e₃ + c₃₁e₃e₁ + c₁₂₃e₁e₂e₃
 
 Stored as 8-element array: [c₀, c₁, c₂, c₃, c₁₂, c₂₃, c₃₁, c₁₂₃]
 """
 scalar: float = 0.0 # Grade 0: c₀
 e1: float = 0.0 # Grade 1: c₁
 e2: float = 0.0 # Grade 1: c₂
 e3: float = 0.0 # Grade 1: c₃
 e12: float = 0.0 # Grade 2: c₁₂ (bivector)
 e23: float = 0.0 # Grade 2: c₂₃ (bivector)
 e31: float = 0.0 # Grade 2: c₃₁ (bivector)
 e123: float = 0.0 # Grade 3: c₁₂₃ (pseudoscalar)
 
 def to_array(self) -> np.ndarray:
 """Convert to 8-element array."""
 return np.array([
 self.scalar, self.e1, self.e2, self.e3,
 self.e12, self.e23, self.e31, self.e123
 ])
 
 @classmethod
 def from_array(cls, arr: np.ndarray) -> 'CliffordElement':
 """Create from 8-element array."""
 assert len(arr) == 8, f"Expected 8 elements, got {len(arr)}"
 return cls(
 scalar=float(arr[0]),
 e1=float(arr[1]),
 e2=float(arr[2]),
 e3=float(arr[3]),
 e12=float(arr[4]),
 e23=float(arr[5]),
 e31=float(arr[6]),
 e123=float(arr[7])
 )
 
 def __mul__(self, other: 'CliffordElement') -> 'CliffordElement':
 """
 Clifford product (geometric product).
 
 Per ENTPC.tex: eᵢeⱼ + eⱼeᵢ = 2δᵢⱼ
 
 This gives:
 - e₁² = e₂² = e₃² = 1
 - e₁e₂ = -e₂e₁ (anticommutative)
 - e₁e₂e₃ = pseudoscalar
 """
 a = self.to_array()
 b = other.to_array()
 
 # Result array
 c = np.zeros(8)
 
 # Scalar part (grade 0)
 c[0] = (a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3] 
 - a[4]*b[4] - a[5]*b[5] - a[6]*b[6] - a[7]*b[7])
 
 # Vector parts (grade 1)
 c[1] = (a[0]*b[1] + a[1]*b[0] - a[4]*b[2] + a[6]*b[3] 
 + a[2]*b[4] - a[3]*b[6] - a[7]*b[5])
 c[2] = (a[0]*b[2] + a[2]*b[0] + a[4]*b[1] - a[5]*b[3] 
 - a[1]*b[4] + a[3]*b[5] - a[7]*b[6])
 c[3] = (a[0]*b[3] + a[3]*b[0] - a[6]*b[1] + a[5]*b[2] 
 + a[1]*b[6] - a[2]*b[5] - a[7]*b[4])
 
 # Bivector parts (grade 2)
 c[4] = (a[0]*b[4] + a[4]*b[0] + a[1]*b[2] - a[2]*b[1] 
 + a[7]*b[6] - a[6]*b[7] + a[3]*b[7])
 c[5] = (a[0]*b[5] + a[5]*b[0] + a[2]*b[3] - a[3]*b[2] 
 + a[7]*b[4] - a[4]*b[7] + a[1]*b[7])
 c[6] = (a[0]*b[6] + a[6]*b[0] + a[3]*b[1] - a[1]*b[3] 
 + a[7]*b[5] - a[5]*b[7] + a[2]*b[7])
 
 # Pseudoscalar part (grade 3)
 c[7] = (a[0]*b[7] + a[7]*b[0] + a[1]*b[5] + a[2]*b[6] 
 + a[3]*b[4] + a[4]*b[3] + a[5]*b[1] + a[6]*b[2])
 
 return CliffordElement.from_array(c)
 
 def __add__(self, other: 'CliffordElement') -> 'CliffordElement':
 """Addition (component-wise)."""
 return CliffordElement.from_array(self.to_array() + other.to_array())
 
 def __sub__(self, other: 'CliffordElement') -> 'CliffordElement':
 """Subtraction (component-wise)."""
 return CliffordElement.from_array(self.to_array() - other.to_array())
 
 def __rmul__(self, scalar: float) -> 'CliffordElement':
 """Scalar multiplication."""
 return CliffordElement.from_array(scalar * self.to_array())
 
 def grade_projection(self, grade: int) -> 'CliffordElement':
 """
 Project to specific grade.
 
 Args:
 grade: 0 (scalar), 1 (vector), 2 (bivector), 3 (pseudoscalar)
 
 Returns:
 Clifford element with only specified grade components
 """
 if grade == 0:
 return CliffordElement(scalar=self.scalar)
 elif grade == 1:
 return CliffordElement(e1=self.e1, e2=self.e2, e3=self.e3)
 elif grade == 2:
 return CliffordElement(e12=self.e12, e23=self.e23, e31=self.e31)
 elif grade == 3:
 return CliffordElement(e123=self.e123)
 else:
 raise ValueError(f"Grade must be 0, 1, 2, or 3, got {grade}")
 
 def norm(self) -> float:
 """Compute norm of Clifford element."""
 arr = self.to_array()
 return np.sqrt(np.sum(arr**2))
 
 def __repr__(self) -> str:
 return (f"CliffordElement({self.scalar:.4f} + {self.e1:.4f}e₁ + {self.e2:.4f}e₂ + "
 f"{self.e3:.4f}e₃ + {self.e12:.4f}e₁₂ + {self.e23:.4f}e₂₃ + "
 f"{self.e31:.4f}e₃₁ + {self.e123:.4f}e₁₂₃)")

def quaternion_to_clifford(q_array: np.ndarray) -> CliffordElement:
 """
 Map quaternion to even subalgebra of Cl(3,0).
 
 Per ENTPC.tex: Quaternions are isomorphic to even subalgebra.
 
 Quaternion q = a + bi + cj + dk maps to:
 - a → scalar
 - bi → e₂₃ (bivector)
 - cj → e₃₁ (bivector)
 - dk → e₁₂ (bivector)
 
 Args:
 q_array: Quaternion as [a, b, c, d]
 
 Returns:
 CliffordElement in even subalgebra
 """
 assert len(q_array) == 4, f"Expected quaternion [a,b,c,d], got {len(q_array)}"
 
 a, b, c, d = q_array
 
 # Map to even subalgebra (scalar + bivectors)
 return CliffordElement(
 scalar=a,
 e23=b, # i → e₂₃
 e31=c, # j → e₃₁
 e12=d # k → e₁₂
 )

def rotor_from_bivector(bivector: CliffordElement, angle: float) -> CliffordElement:
 """
 Create rotor from bivector.
 
 Per ENTPC.tex: Π(q) = e^(-B/2) where B is bivector.
 
 Rotor: R = e^(θB/2) = cos(θ/2) + sin(θ/2)B
 
 Args:
 bivector: Bivector element (grade 2)
 angle: Rotation angle θ
 
 Returns:
 Rotor (even element)
 """
 # Extract bivector components
 B = bivector.grade_projection(2)
 
 # Compute norm of bivector
 B_norm = np.sqrt(B.e12**2 + B.e23**2 + B.e31**2)
 
 if B_norm < 1e-12:
 # Zero bivector → identity rotor
 return CliffordElement(scalar=1.0)
 
 # Normalize bivector
 B_unit = CliffordElement(
 e12=B.e12/B_norm,
 e23=B.e23/B_norm,
 e31=B.e31/B_norm
 )
 
 # Rotor: cos(θ/2) + sin(θ/2)B_unit
 half_angle = angle / 2.0
 rotor = CliffordElement(
 scalar=np.cos(half_angle),
 e12=np.sin(half_angle) * B_unit.e12,
 e23=np.sin(half_angle) * B_unit.e23,
 e31=np.sin(half_angle) * B_unit.e31
 )
 
 return rotor

def semantic_encoding_bivector(concept_a: np.ndarray, concept_b: np.ndarray) -> CliffordElement:
 """
 Encode semantic relation between concepts as bivector.
 
 Per ENTPC.tex: Bivectors encode semantic and relational information.
 
 Example: "A causes B" → bivector e₁ ∧ e₂
 
 Args:
 concept_a: Vector representation of concept A (3D)
 concept_b: Vector representation of concept B (3D)
 
 Returns:
 Bivector encoding relation A→B
 """
 assert len(concept_a) == 3 and len(concept_b) == 3, \
 "Concepts must be 3D vectors"
 
 # Create Clifford vectors
 A = CliffordElement(e1=concept_a[0], e2=concept_a[1], e3=concept_a[2])
 B = CliffordElement(e1=concept_b[0], e2=concept_b[1], e3=concept_b[2])
 
 # Outer product (wedge product) A ∧ B
 # For vectors: A ∧ B = (AB - BA)/2
 AB = A * B
 BA = B * A
 wedge = 0.5 * (AB - BA)
 
 # Extract bivector part
 return wedge.grade_projection(2)

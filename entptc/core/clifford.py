"""

Clifford Algebra Cl(3,0) Implementation

Reference: ENTPC.tex Definition 2.3 (lines 242-252)

 

From ENTPC.tex:

The Clifford algebra Cl(3,0) is generated by basis vectors {e1, e2, e3} satisfying

the relation e_i e_j + e_j e_i = 2δ_ij. The algebra has a graded structure of

dimension 2^3 = 8, consisting of:

- Scalars (grade 0): 1 element

- Vectors (grade 1): 3 elements (e1, e2, e3)

- Bivectors (grade 2): 3 elements (e12, e23, e31)

- Pseudoscalar (grade 3): 1 element (e123)

 

In EntPTC, this algebra serves as the global integration layer where bivectors

encode semantic and relational information geometrically. Quaternions, which are

isomorphic to the even subalgebra of Cl(3,0), act as the local stability layer.

 

Two-stage process per ENTPC.tex:

1. Local quaternionic filtering: Context-dependent state stabilization

2. Embedding into global Clifford algebra: Semantic and relational integration

 

Transition formalized by mapping Π: H_H → Cl(3,0), expressed as Π(q) = e^(-B/2)

where B is a bivector derived from semantic context.

"""

 

import numpy as np

from typing import Dict, Tuple, Optional, Union

from dataclasses import dataclass

 

 

@dataclass

class CliffordElement:

    """

    Element of Cl(3,0) represented by coefficients for each basis element.

 

    Basis elements (dimension 8):

    - Grade 0: 1 (scalar)

    - Grade 1: e1, e2, e3 (vectors)

    - Grade 2: e12, e23, e31 (bivectors)

    - Grade 3: e123 (pseudoscalar)

 

    Per ENTPC.tex Definition 2.3: bivectors encode semantic and relational

    information geometrically.

    """

    # Coefficients for each grade

    scalar: float = 0.0      # Grade 0: coefficient of 1

    e1: float = 0.0          # Grade 1: coefficient of e1

    e2: float = 0.0          # Grade 1: coefficient of e2

    e3: float = 0.0          # Grade 1: coefficient of e3

    e12: float = 0.0         # Grade 2: coefficient of e1∧e2

    e23: float = 0.0         # Grade 2: coefficient of e2∧e3

    e31: float = 0.0         # Grade 2: coefficient of e3∧e1

    e123: float = 0.0        # Grade 3: coefficient of e1∧e2∧e3

 

    def to_array(self) -> np.ndarray:

        """Convert to 8-element array [scalar, e1, e2, e3, e12, e23, e31, e123]."""

        return np.array([

            self.scalar, self.e1, self.e2, self.e3,

            self.e12, self.e23, self.e31, self.e123

        ])

 

    @classmethod

    def from_array(cls, arr: np.ndarray) -> 'CliffordElement':

        """Create from 8-element array."""

        assert len(arr) == 8, f"Expected 8 elements, got {len(arr)}"

        return cls(

            scalar=float(arr[0]), e1=float(arr[1]), e2=float(arr[2]),

            e3=float(arr[3]), e12=float(arr[4]), e23=float(arr[5]),

            e31=float(arr[6]), e123=float(arr[7])

        )

 

    def grade(self, k: int) -> 'CliffordElement':

        """Extract grade-k component."""

        if k == 0:

            return CliffordElement(scalar=self.scalar)

        elif k == 1:

            return CliffordElement(e1=self.e1, e2=self.e2, e3=self.e3)

        elif k == 2:

            return CliffordElement(e12=self.e12, e23=self.e23, e31=self.e31)

        elif k == 3:

            return CliffordElement(e123=self.e123)

        else:

            return CliffordElement()

 

    def even_part(self) -> 'CliffordElement':

        """

        Extract even subalgebra (grades 0 and 2).

 

        Per ENTPC.tex: Quaternions are isomorphic to the even subalgebra of Cl(3,0).

        """

        return CliffordElement(

            scalar=self.scalar,

            e12=self.e12, e23=self.e23, e31=self.e31

        )

 

    def norm_squared(self) -> float:

        """Compute squared norm."""

        arr = self.to_array()

        return float(np.sum(arr ** 2))

 

    def norm(self) -> float:

        """Compute norm."""

        return np.sqrt(self.norm_squared())

 

 

class CliffordAlgebra:

    """

    Clifford Algebra Cl(3,0) implementation per ENTPC.tex Definition 2.3.

 

    Multiplication table derived from e_i e_j + e_j e_i = 2δ_ij:

    - e1*e1 = e2*e2 = e3*e3 = 1

    - e1*e2 = -e2*e1 = e12

    - e2*e3 = -e3*e2 = e23

    - e3*e1 = -e1*e3 = e31

    - e12*e3 = e1*e2*e3 = e123

    - etc.

    """

 

    # Basis element indices

    SCALAR = 0

    E1 = 1

    E2 = 2

    E3 = 3

    E12 = 4

    E23 = 5

    E31 = 6

    E123 = 7

 

    def __init__(self):

        """Initialize Cl(3,0) with precomputed multiplication table."""

        # Multiplication table: mult_table[i, j] = (result_index, sign)

        # where e_i * e_j = sign * e_{result_index}

        self._build_multiplication_table()

 

    def _build_multiplication_table(self):

        """

        Build the geometric product multiplication table for Cl(3,0).

 

        From ENTPC.tex: e_i e_j + e_j e_i = 2δ_ij

        This means:

        - e_i * e_i = 1

        - e_i * e_j = -e_j * e_i for i ≠ j

        """

        # Table stores (coefficients for all 8 basis elements) for each product

        # mult_table[i, j, :] gives coefficients for e_i * e_j

        self.mult_table = np.zeros((8, 8, 8), dtype=float)

 

        # Scalar * anything = anything

        for i in range(8):

            self.mult_table[0, i, i] = 1.0

            self.mult_table[i, 0, i] = 1.0

 

        # Vector * Vector products (grade 1 * grade 1)

        # e1*e1 = 1, e2*e2 = 1, e3*e3 = 1

        self.mult_table[1, 1, 0] = 1.0  # e1*e1 = 1

        self.mult_table[2, 2, 0] = 1.0  # e2*e2 = 1

        self.mult_table[3, 3, 0] = 1.0  # e3*e3 = 1

 

        # e1*e2 = e12, e2*e1 = -e12

        self.mult_table[1, 2, 4] = 1.0   # e1*e2 = e12

        self.mult_table[2, 1, 4] = -1.0  # e2*e1 = -e12

 

        # e2*e3 = e23, e3*e2 = -e23

        self.mult_table[2, 3, 5] = 1.0   # e2*e3 = e23

        self.mult_table[3, 2, 5] = -1.0  # e3*e2 = -e23

 

        # e3*e1 = e31, e1*e3 = -e31

        self.mult_table[3, 1, 6] = 1.0   # e3*e1 = e31

        self.mult_table[1, 3, 6] = -1.0  # e1*e3 = -e31

 

        # Vector * Bivector products

        # e1*e12 = e1*e1*e2 = e2

        self.mult_table[1, 4, 2] = 1.0   # e1*e12 = e2

        self.mult_table[4, 1, 2] = -1.0  # e12*e1 = -e2

 

        # e2*e12 = e2*e1*e2 = -e1*e2*e2 = -e1

        self.mult_table[2, 4, 1] = -1.0  # e2*e12 = -e1

        self.mult_table[4, 2, 1] = 1.0   # e12*e2 = e1

 

        # e1*e23 = e123

        self.mult_table[1, 5, 7] = 1.0   # e1*e23 = e123

        self.mult_table[5, 1, 7] = 1.0   # e23*e1 = e123

 

        # e2*e23 = e3

        self.mult_table[2, 5, 3] = 1.0   # e2*e23 = e3

        self.mult_table[5, 2, 3] = -1.0  # e23*e2 = -e3

 

        # e3*e23 = -e2

        self.mult_table[3, 5, 2] = -1.0  # e3*e23 = -e2

        self.mult_table[5, 3, 2] = 1.0   # e23*e3 = e2

 

        # e1*e31 = -e3

        self.mult_table[1, 6, 3] = -1.0  # e1*e31 = -e3

        self.mult_table[6, 1, 3] = 1.0   # e31*e1 = e3

 

        # e3*e31 = e1

        self.mult_table[3, 6, 1] = 1.0   # e3*e31 = e1

        self.mult_table[6, 3, 1] = -1.0  # e31*e3 = -e1

 

        # e2*e31 = -e123

        self.mult_table[2, 6, 7] = -1.0  # e2*e31 = -e123

        self.mult_table[6, 2, 7] = -1.0  # e31*e2 = -e123

 

        # Bivector * Bivector products

        # e12*e12 = e1*e2*e1*e2 = -e1*e1*e2*e2 = -1

        self.mult_table[4, 4, 0] = -1.0  # e12*e12 = -1

        self.mult_table[5, 5, 0] = -1.0  # e23*e23 = -1

        self.mult_table[6, 6, 0] = -1.0  # e31*e31 = -1

 

        # e12*e23 = e1*e3 = -e31

        self.mult_table[4, 5, 6] = -1.0  # e12*e23 = -e31

        self.mult_table[5, 4, 6] = 1.0   # e23*e12 = e31

 

        # e23*e31 = -e12

        self.mult_table[5, 6, 4] = -1.0  # e23*e31 = -e12

        self.mult_table[6, 5, 4] = 1.0   # e31*e23 = e12

 

        # e31*e12 = -e23

        self.mult_table[6, 4, 5] = -1.0  # e31*e12 = -e23

        self.mult_table[4, 6, 5] = 1.0   # e12*e31 = e23

 

        # Bivector * Pseudoscalar and Vector * Pseudoscalar

        # e12*e123 = e12*e1*e2*e3 = -e3

        self.mult_table[4, 7, 3] = -1.0  # e12*e123 = -e3

        self.mult_table[7, 4, 3] = -1.0  # e123*e12 = -e3

 

        # e23*e123 = -e1

        self.mult_table[5, 7, 1] = -1.0  # e23*e123 = -e1

        self.mult_table[7, 5, 1] = -1.0  # e123*e23 = -e1

 

        # e31*e123 = -e2

        self.mult_table[6, 7, 2] = -1.0  # e31*e123 = -e2

        self.mult_table[7, 6, 2] = -1.0  # e123*e31 = -e2

 

        # e1*e123 = e23

        self.mult_table[1, 7, 5] = 1.0   # e1*e123 = e23

        self.mult_table[7, 1, 5] = -1.0  # e123*e1 = -e23

 

        # e2*e123 = e31

        self.mult_table[2, 7, 6] = 1.0   # e2*e123 = e31

        self.mult_table[7, 2, 6] = -1.0  # e123*e2 = -e31

 

        # e3*e123 = e12

        self.mult_table[3, 7, 4] = 1.0   # e3*e123 = e12

        self.mult_table[7, 3, 4] = -1.0  # e123*e3 = -e12

 

        # e123*e123 = -1

        self.mult_table[7, 7, 0] = -1.0  # e123*e123 = -1

 

    def multiply(self, a: CliffordElement, b: CliffordElement) -> CliffordElement:

        """

        Compute geometric product a * b.

 

        Uses the Clifford relation e_i e_j + e_j e_i = 2δ_ij from ENTPC.tex Def 2.3.

        """

        a_arr = a.to_array()

        b_arr = b.to_array()

 

        result = np.zeros(8)

        for i in range(8):

            for j in range(8):

                if abs(a_arr[i]) > 1e-12 and abs(b_arr[j]) > 1e-12:

                    result += a_arr[i] * b_arr[j] * self.mult_table[i, j, :]

 

        return CliffordElement.from_array(result)

 

    def wedge(self, a: CliffordElement, b: CliffordElement) -> CliffordElement:

        """

        Compute outer (wedge) product a ∧ b.

 

        The wedge product extracts the antisymmetric part:

        a ∧ b = (a*b - b*a) / 2 for vectors

 

        Per ENTPC.tex: Bivectors (wedge products) encode semantic relations.

        """

        ab = self.multiply(a, b)

        ba = self.multiply(b, a)

 

        ab_arr = ab.to_array()

        ba_arr = ba.to_array()

 

        result = (ab_arr - ba_arr) / 2.0

        return CliffordElement.from_array(result)

 

    def inner(self, a: CliffordElement, b: CliffordElement) -> CliffordElement:

        """

        Compute inner (dot) product a · b.

 

        The inner product extracts the symmetric part:

        a · b = (a*b + b*a) / 2 for vectors

        """

        ab = self.multiply(a, b)

        ba = self.multiply(b, a)

 

        ab_arr = ab.to_array()

        ba_arr = ba.to_array()

 

        result = (ab_arr + ba_arr) / 2.0

        return CliffordElement.from_array(result)

 

    def exp_bivector(self, B: CliffordElement) -> CliffordElement:

        """

        Compute exponential of a bivector: e^B.

 

        Per ENTPC.tex Definition 2.3:

        The mapping Π: H_H → Cl(3,0) is expressed as Π(q) = e^(-B/2)

        where B is a bivector derived from semantic context.

 

        For a bivector B with B² = -|B|² (pure bivector squares to negative scalar),

        we have: e^B = cos(|B|) + sin(|B|) * B/|B|

        """

        # Extract bivector components only

        b_vec = np.array([B.e12, B.e23, B.e31])

        b_norm = np.linalg.norm(b_vec)

 

        if b_norm < 1e-12:

            # Near zero bivector: e^0 = 1

            return CliffordElement(scalar=1.0)

 

        # e^B = cos(|B|) + sin(|B|) * B/|B|

        cos_b = np.cos(b_norm)

        sin_b = np.sin(b_norm)

 

        b_unit = b_vec / b_norm

 

        return CliffordElement(

            scalar=cos_b,

            e12=sin_b * b_unit[0],

            e23=sin_b * b_unit[1],

            e31=sin_b * b_unit[2]

        )

 

    def rotor_from_bivector(self, B: CliffordElement, angle: float) -> CliffordElement:

        """

        Create a rotor from a bivector and angle: R = e^(-B*angle/2)

 

        Per ENTPC.tex: Rotors are used for semantic transformation.

        """

        scaled_B = CliffordElement(

            e12=-B.e12 * angle / 2,

            e23=-B.e23 * angle / 2,

            e31=-B.e31 * angle / 2

        )

        return self.exp_bivector(scaled_B)

 

    def apply_rotor(self, R: CliffordElement, v: CliffordElement) -> CliffordElement:

        """

        Apply rotor transformation: v' = R * v * R†

 

        Where R† is the reverse of R.

        """

        R_rev = CliffordElement(

            scalar=R.scalar,

            e12=-R.e12, e23=-R.e23, e31=-R.e31

        )

 

        Rv = self.multiply(R, v)

        return self.multiply(Rv, R_rev)

 

    def quaternion_to_clifford(self, q_a: float, q_b: float,

                                q_c: float, q_d: float) -> CliffordElement:

        """

        Map quaternion to even subalgebra of Cl(3,0).

 

        Per ENTPC.tex Definition 2.3:

        Quaternions are isomorphic to the even subalgebra of Cl(3,0).

 

        Mapping: q = a + bi + cj + dk → a + b*e23 + c*e31 + d*e12

        (using the isomorphism i↔e23, j↔e31, k↔e12)

        """

        return CliffordElement(

            scalar=q_a,

            e12=q_d,   # k → e12

            e23=q_b,   # i → e23

            e31=q_c    # j → e31

        )

 

    def clifford_to_quaternion(self, c: CliffordElement) -> Tuple[float, float, float, float]:

        """

        Map even subalgebra element back to quaternion.

 

        Returns (a, b, c, d) for quaternion a + bi + cj + dk.

        """

        return (c.scalar, c.e23, c.e31, c.e12)

 

    def semantic_bivector(self, relation_type: str) -> CliffordElement:

        """

        Create a bivector encoding a semantic relation.

 

        Per ENTPC.tex Definition 2.3:

        Bivectors encode semantic and relational information geometrically.

        Example from TeX: R_cause = e1 ∧ e2 encodes "A causes B".

 

        This is a placeholder that should be customized based on the

        specific semantic encoding scheme used in the analysis.

        """

        # Standard semantic relations mapped to bivector planes

        relations = {

            'cause': CliffordElement(e12=1.0),      # Causal relation

            'correlate': CliffordElement(e23=1.0),  # Correlation

            'temporal': CliffordElement(e31=1.0),   # Temporal ordering

            'spatial': CliffordElement(e12=0.5, e23=0.5, e31=0.5),  # Spatial

        }

 

        return relations.get(relation_type, CliffordElement(e12=1.0))

 

 

def create_clifford_embedding_map():

    """

    Create the mapping Π: H_H → Cl(3,0) per ENTPC.tex Definition 2.3.

 

    This implements the two-stage process:

    1. Local quaternionic filtering (done in quaternion module)

    2. Embedding into global Clifford algebra for semantic integration

 

    Returns a callable that takes quaternion components and returns

    the corresponding Clifford element.

    """

    algebra = CliffordAlgebra()

 

    def embedding_map(q_a: float, q_b: float, q_c: float, q_d: float,

                      semantic_context: Optional[CliffordElement] = None

                      ) -> CliffordElement:

        """

        Map quaternion to Clifford element with optional semantic context.

 

        Per ENTPC.tex: Π(q) = e^(-B/2) where B is semantic bivector.

        The full mapping incorporates both the quaternion state and

        the semantic context.

        """

        # First: map quaternion to even subalgebra

        q_clifford = algebra.quaternion_to_clifford(q_a, q_b, q_c, q_d)

 

        if semantic_context is not None:

            # Apply semantic transformation via rotor

            rotor = algebra.exp_bivector(CliffordElement(

                e12=-semantic_context.e12 / 2,

                e23=-semantic_context.e23 / 2,

                e31=-semantic_context.e31 / 2

            ))

            return algebra.apply_rotor(rotor, q_clifford)

 

        return q_clifford

 

    return embedding_map